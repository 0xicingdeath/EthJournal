/// <reference types="bignumber.js" />
import { SignedOrder, Order } from '../types';
import { TokenWrapper } from '../contract_wrappers/token_wrapper';
import { ExchangeWrapper } from '../contract_wrappers/exchange_wrapper';
import { ExchangeTransferSimulator } from './exchange_transfer_simulator';
export declare class OrderValidationUtils {
    private tokenWrapper;
    private exchangeWrapper;
    constructor(tokenWrapper: TokenWrapper, exchangeWrapper: ExchangeWrapper);
    validateOrderFillableOrThrowAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, zrxTokenAddress: string, expectedFillTakerTokenAmount?: BigNumber.BigNumber): Promise<void>;
    validateFillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber.BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<BigNumber.BigNumber>;
    validateFillOrKillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber.BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<void>;
    validateCancelOrderThrowIfInvalidAsync(order: Order, cancelTakerTokenAmount: BigNumber.BigNumber, unavailableTakerTokenAmount: BigNumber.BigNumber): Promise<void>;
    validateFillOrderBalancesAllowancesThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber.BigNumber, senderAddress: string, zrxTokenAddress: string): Promise<void>;
    private validateRemainingFillAmountNotZeroOrThrow(takerTokenAmount, unavailableTakerTokenAmount);
    private validateOrderNotExpiredOrThrow(expirationUnixTimestampSec);
    private getFillMakerTokenAmount(signedOrder, fillTakerTokenAmount);
}
