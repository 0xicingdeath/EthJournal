import * as Web3 from 'web3';
import { Web3Wrapper } from '../web3_wrapper';
import { AbiDecoder } from '../utils/abi_decoder';
import { Artifact, LogWithDecodedArgs, RawLog, ContractEvents, SubscriptionOpts, IndexedFilterValues, EventCallback, ContractEventArgs } from '../types';
export declare class ContractWrapper {
    protected _web3Wrapper: Web3Wrapper;
    private _abiDecoder?;
    private _blockAndLogStreamer;
    private _blockAndLogStreamInterval;
    private _filters;
    private _filterCallbacks;
    private _onLogAddedSubscriptionToken;
    private _onLogRemovedSubscriptionToken;
    constructor(web3Wrapper: Web3Wrapper, abiDecoder?: AbiDecoder);
    protected _subscribe<ArgsType extends ContractEventArgs>(address: string, eventName: ContractEvents, indexFilterValues: IndexedFilterValues, abi: Web3.ContractAbi, callback: EventCallback<ArgsType>): string;
    protected _unsubscribe(filterToken: string): void;
    protected _getLogsAsync<ArgsType extends ContractEventArgs>(address: string, eventName: ContractEvents, subscriptionOpts: SubscriptionOpts, indexFilterValues: IndexedFilterValues, abi: Web3.ContractAbi): Promise<Array<LogWithDecodedArgs<ArgsType>>>;
    protected _tryToDecodeLogOrNoop<ArgsType extends ContractEventArgs>(log: Web3.LogEntry): LogWithDecodedArgs<ArgsType> | RawLog;
    protected _instantiateContractIfExistsAsync<ContractType extends Web3.ContractInstance>(artifact: Artifact, addressIfExists?: string): Promise<ContractType>;
    private _onLogStateChanged<ArgsType>(removed, log);
    private _startBlockAndLogStream();
    private _stopBlockAndLogStream();
    private _reconcileBlockAsync();
}
