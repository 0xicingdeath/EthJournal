"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var chai = require("chai");
var BigNumber = require("bignumber.js");
var chai_setup_1 = require("./utils/chai_setup");
var web3_factory_1 = require("./utils/web3_factory");
var src_1 = require("../src");
var token_utils_1 = require("./utils/token_utils");
var blockchain_lifecycle_1 = require("./utils/blockchain_lifecycle");
var fill_scenarios_1 = require("./utils/fill_scenarios");
var order_validation_utils_1 = require("../src/utils/order_validation_utils");
chai_setup_1.chaiSetup.configure();
var expect = chai.expect;
var blockchainLifecycle = new blockchain_lifecycle_1.BlockchainLifecycle();
describe('OrderValidation', function () {
    var web3;
    var zeroEx;
    var userAddresses;
    var tokens;
    var tokenUtils;
    var exchangeContractAddress;
    var zrxTokenAddress;
    var fillScenarios;
    var makerTokenAddress;
    var takerTokenAddress;
    var coinbase;
    var makerAddress;
    var takerAddress;
    var feeRecipient;
    var orderValidationUtils;
    var fillableAmount = new BigNumber(5);
    var fillTakerAmount = new BigNumber(5);
    var shouldThrowOnInsufficientBalanceOrAllowance = false;
    before(function () { return __awaiter(_this, void 0, void 0, function () {
        var _a, makerToken, takerToken;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    web3 = web3_factory_1.web3Factory.create();
                    zeroEx = new src_1.ZeroEx(web3.currentProvider);
                    return [4 /*yield*/, zeroEx.exchange.getContractAddressAsync()];
                case 1:
                    exchangeContractAddress = _b.sent();
                    return [4 /*yield*/, zeroEx.getAvailableAddressesAsync()];
                case 2:
                    userAddresses = _b.sent();
                    coinbase = userAddresses[0], makerAddress = userAddresses[1], takerAddress = userAddresses[2], feeRecipient = userAddresses[3];
                    return [4 /*yield*/, zeroEx.tokenRegistry.getTokensAsync()];
                case 3:
                    tokens = _b.sent();
                    tokenUtils = new token_utils_1.TokenUtils(tokens);
                    zrxTokenAddress = tokenUtils.getProtocolTokenOrThrow().address;
                    fillScenarios = new fill_scenarios_1.FillScenarios(zeroEx, userAddresses, tokens, zrxTokenAddress, exchangeContractAddress);
                    _a = tokenUtils.getNonProtocolTokens(), makerToken = _a[0], takerToken = _a[1];
                    makerTokenAddress = makerToken.address;
                    takerTokenAddress = takerToken.address;
                    orderValidationUtils = new order_validation_utils_1.OrderValidationUtils(zeroEx.token, zeroEx.exchange);
                    return [2 /*return*/];
            }
        });
    }); });
    beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.startAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.revertAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    describe('validateOrderFillableOrThrowAsync', function () {
        it('should succeed if the order is fillable', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        return [4 /*yield*/, zeroEx.exchange.validateOrderFillableOrThrowAsync(signedOrder)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should succeed if the order is asymmetric and fillable', function () { return __awaiter(_this, void 0, void 0, function () {
            var makerFillableAmount, takerFillableAmount, signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        makerFillableAmount = fillableAmount;
                        takerFillableAmount = fillableAmount.minus(4);
                        return [4 /*yield*/, fillScenarios.createAsymmetricFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, makerFillableAmount, takerFillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        return [4 /*yield*/, zeroEx.exchange.validateOrderFillableOrThrowAsync(signedOrder)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw when the order is fully filled or cancelled', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateOrderFillableOrThrowAsync(signedOrder)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero)];
                }
            });
        }); });
        it('should throw when order is expired', function () { return __awaiter(_this, void 0, void 0, function () {
            var expirationInPast, signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        expirationInPast = new BigNumber(1496826058);
                        return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount, expirationInPast)];
                    case 1:
                        signedOrder = _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateOrderFillableOrThrowAsync(signedOrder)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderFillExpired)];
                }
            });
        }); });
    });
    describe('validateFillOrderAndThrowIfInvalidAsync', function () {
        it('should throw when the fill amount is zero', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder, zeroFillAmount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        zeroFillAmount = new BigNumber(0);
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, zeroFillAmount, takerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderFillAmountZero)];
                }
            });
        }); });
        it('should throw when the signature is invalid', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        // 27 <--> 28
                        signedOrder.ecSignature.v = 27 + (28 - signedOrder.ecSignature.v);
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, fillableAmount, takerAddress)).to.be.rejectedWith(src_1.ZeroExError.InvalidSignature)];
                }
            });
        }); });
        it('should throw when the order is fully filled or cancelled', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, fillableAmount, takerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero)];
                }
            });
        }); });
        it('should throw when sender is not a taker', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder, nonTakerAddress;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        nonTakerAddress = userAddresses[6];
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, fillTakerAmount, nonTakerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.TransactionSenderIsNotFillOrderTaker)];
                }
            });
        }); });
        it('should throw when order is expired', function () { return __awaiter(_this, void 0, void 0, function () {
            var expirationInPast, signedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        expirationInPast = new BigNumber(1496826058);
                        return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount, expirationInPast)];
                    case 1:
                        signedOrder = _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderFillExpired)];
                }
            });
        }); });
        it('should throw when there a rounding error would have occurred', function () { return __awaiter(_this, void 0, void 0, function () {
            var makerAmount, takerAmount, signedOrder, fillTakerAmountThatCausesRoundingError;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        makerAmount = new BigNumber(3);
                        takerAmount = new BigNumber(5);
                        return [4 /*yield*/, fillScenarios.createAsymmetricFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, makerAmount, takerAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        fillTakerAmountThatCausesRoundingError = new BigNumber(3);
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrderThrowIfInvalidAsync(signedOrder, fillTakerAmountThatCausesRoundingError, takerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.OrderFillRoundingError)];
                }
            });
        }); });
    });
    describe('#validateFillOrKillOrderAndThrowIfInvalidAsync', function () {
        it('should throw if remaining fillAmount is less then the desired fillAmount', function () { return __awaiter(_this, void 0, void 0, function () {
            var signedOrder, tooLargeFillAmount, fillAmountDifference;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _a.sent();
                        tooLargeFillAmount = new BigNumber(7);
                        fillAmountDifference = tooLargeFillAmount.minus(fillableAmount);
                        return [4 /*yield*/, zeroEx.token.transferAsync(takerTokenAddress, coinbase, takerAddress, fillAmountDifference)];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(takerTokenAddress, takerAddress, tooLargeFillAmount)];
                    case 3:
                        _a.sent();
                        return [4 /*yield*/, zeroEx.token.transferAsync(makerTokenAddress, coinbase, makerAddress, fillAmountDifference)];
                    case 4:
                        _a.sent();
                        return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerTokenAddress, makerAddress, tooLargeFillAmount)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateFillOrKillOrderThrowIfInvalidAsync(signedOrder, tooLargeFillAmount, takerAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientRemainingFillAmount)];
                }
            });
        }); });
    });
    describe('validateCancelOrderAndThrowIfInvalidAsync', function () {
        var signedOrder;
        var orderHashHex;
        var cancelAmount = new BigNumber(3);
        beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, makerToken, takerToken;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        coinbase = userAddresses[0], makerAddress = userAddresses[1], takerAddress = userAddresses[2];
                        _a = tokenUtils.getNonProtocolTokens(), makerToken = _a[0], takerToken = _a[1];
                        makerTokenAddress = makerToken.address;
                        takerTokenAddress = takerToken.address;
                        return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                    case 1:
                        signedOrder = _b.sent();
                        orderHashHex = src_1.ZeroEx.getOrderHashHex(signedOrder);
                        return [2 /*return*/];
                }
            });
        }); });
        it('should throw when cancel amount is zero', function () { return __awaiter(_this, void 0, void 0, function () {
            var zeroCancelAmount;
            return __generator(this, function (_a) {
                zeroCancelAmount = new BigNumber(0);
                return [2 /*return*/, expect(zeroEx.exchange.validateCancelOrderThrowIfInvalidAsync(signedOrder, zeroCancelAmount))
                        .to.be.rejectedWith(src_1.ExchangeContractErrs.OrderCancelAmountZero)];
            });
        }); });
        it('should throw when order is expired', function () { return __awaiter(_this, void 0, void 0, function () {
            var expirationInPast, expiredSignedOrder;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        expirationInPast = new BigNumber(1496826058);
                        return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount, expirationInPast)];
                    case 1:
                        expiredSignedOrder = _a.sent();
                        orderHashHex = src_1.ZeroEx.getOrderHashHex(expiredSignedOrder);
                        return [2 /*return*/, expect(zeroEx.exchange.validateCancelOrderThrowIfInvalidAsync(expiredSignedOrder, cancelAmount))
                                .to.be.rejectedWith(src_1.ExchangeContractErrs.OrderCancelExpired)];
                }
            });
        }); });
        it('should throw when order is already cancelled or filled', function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, expect(zeroEx.exchange.validateCancelOrderThrowIfInvalidAsync(signedOrder, fillableAmount))
                                .to.be.rejectedWith(src_1.ExchangeContractErrs.OrderAlreadyCancelledOrFilled)];
                }
            });
        }); });
    });
    describe('#validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync', function () {
        describe('should throw when not enough balance or allowance to fulfill the order', function () {
            var balanceToSubtractFromMaker = new BigNumber(3);
            var balanceToSubtractFromTaker = new BigNumber(3);
            var lackingAllowance = new BigNumber(3);
            var signedOrder;
            beforeEach('create fillable signed order', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw when maker balance is less than maker fill amount', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, zeroEx.token.transferAsync(makerTokenAddress, makerAddress, coinbase, balanceToSubtractFromMaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerBalance)];
                    }
                });
            }); });
            it('should throw when maker allowance is less than maker fill amount', function () { return __awaiter(_this, void 0, void 0, function () {
                var newAllowanceWhichIsLessThanFillAmount;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            newAllowanceWhichIsLessThanFillAmount = fillTakerAmount.minus(lackingAllowance);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerTokenAddress, makerAddress, newAllowanceWhichIsLessThanFillAmount)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerAllowance)];
                    }
                });
            }); });
        });
        describe('should throw when not enough balance or allowance to pay fees', function () {
            var makerFee = new BigNumber(2);
            var takerFee = new BigNumber(2);
            var signedOrder;
            beforeEach('setup', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerTokenAddress, takerTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw when maker doesn\'t have enough balance to pay fees', function () { return __awaiter(_this, void 0, void 0, function () {
                var balanceToSubtractFromMaker;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            balanceToSubtractFromMaker = new BigNumber(1);
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, makerAddress, coinbase, balanceToSubtractFromMaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerFeeBalance)];
                    }
                });
            }); });
            it('should throw when maker doesn\'t have enough allowance to pay fees', function () { return __awaiter(_this, void 0, void 0, function () {
                var newAllowanceWhichIsLessThanFees;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            newAllowanceWhichIsLessThanFees = makerFee.minus(1);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, makerAddress, newAllowanceWhichIsLessThanFees)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerFeeAllowance)];
                    }
                });
            }); });
        });
        describe('should throw on insufficient balance or allowance when makerToken is ZRX', function () {
            var makerFee = new BigNumber(2);
            var takerFee = new BigNumber(2);
            var signedOrder;
            beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(zrxTokenAddress, takerTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw on insufficient balance when makerToken is ZRX', function () { return __awaiter(_this, void 0, void 0, function () {
                var balanceToSubtractFromMaker;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            balanceToSubtractFromMaker = new BigNumber(1);
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, makerAddress, coinbase, balanceToSubtractFromMaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerBalance)];
                    }
                });
            }); });
            it('should throw on insufficient allowance when makerToken is ZRX', function () { return __awaiter(_this, void 0, void 0, function () {
                var oldAllowance, newAllowanceWhichIsInsufficient;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, zeroEx.token.getProxyAllowanceAsync(zrxTokenAddress, makerAddress)];
                        case 1:
                            oldAllowance = _a.sent();
                            newAllowanceWhichIsInsufficient = oldAllowance.minus(1);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, makerAddress, newAllowanceWhichIsInsufficient)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerAllowance)];
                    }
                });
            }); });
        });
        describe('should correctly validate fees amounts if taker token is ZRX', function () {
            var signedOrder;
            var txHash;
            it('should not throw if maker will have enough ZRX to pay fees after the transfer', function () { return __awaiter(_this, void 0, void 0, function () {
                var makerFee, takerFee;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            makerFee = new BigNumber(2);
                            takerFee = new BigNumber(2);
                            return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerTokenAddress, zrxTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, makerAddress, coinbase, makerFee)];
                        case 2:
                            txHash = _a.sent();
                            return [4 /*yield*/, zeroEx.awaitTransactionMinedAsync(txHash)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw if maker will not have enough ZRX to pay fees even after the transfer', function () { return __awaiter(_this, void 0, void 0, function () {
                var makerFee, takerFee;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            makerFee = fillableAmount.plus(1);
                            takerFee = fillableAmount.plus(1);
                            return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerTokenAddress, zrxTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, makerAddress, coinbase, makerFee)];
                        case 2:
                            txHash = _a.sent();
                            return [4 /*yield*/, zeroEx.awaitTransactionMinedAsync(txHash)];
                        case 3:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderMakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientMakerFeeBalance)];
                    }
                });
            }); });
        });
    });
    describe('#validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync', function () {
        describe('should throw when not enough balance or allowance to fulfill the order', function () {
            var balanceToSubtractFromMaker = new BigNumber(3);
            var balanceToSubtractFromTaker = new BigNumber(3);
            var lackingAllowance = new BigNumber(3);
            var signedOrder;
            beforeEach('create fillable signed order', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerTokenAddress, takerTokenAddress, makerAddress, takerAddress, fillableAmount)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw when taker balance is less than fill amount', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, zeroEx.token.transferAsync(takerTokenAddress, takerAddress, coinbase, balanceToSubtractFromTaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerBalance)];
                    }
                });
            }); });
            it('should throw when taker allowance is less than fill amount', function () { return __awaiter(_this, void 0, void 0, function () {
                var newAllowanceWhichIsLessThanFillAmount;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            newAllowanceWhichIsLessThanFillAmount = fillTakerAmount.minus(lackingAllowance);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(takerTokenAddress, takerAddress, newAllowanceWhichIsLessThanFillAmount)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerAllowance)];
                    }
                });
            }); });
        });
        describe('should throw when not enough balance or allowance to pay fees', function () {
            var makerFee = new BigNumber(2);
            var takerFee = new BigNumber(2);
            var signedOrder;
            beforeEach('setup', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerTokenAddress, takerTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw when taker doesn\'t have enough balance to pay fees', function () { return __awaiter(_this, void 0, void 0, function () {
                var balanceToSubtractFromTaker;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            balanceToSubtractFromTaker = new BigNumber(1);
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, takerAddress, coinbase, balanceToSubtractFromTaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerFeeBalance)];
                    }
                });
            }); });
            it('should throw when taker doesn\'t have enough allowance to pay fees', function () { return __awaiter(_this, void 0, void 0, function () {
                var newAllowanceWhichIsLessThanFees;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            newAllowanceWhichIsLessThanFees = makerFee.minus(1);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, takerAddress, newAllowanceWhichIsLessThanFees)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerFeeAllowance)];
                    }
                });
            }); });
        });
        describe('should throw on insufficient balance or allowance when takerToken is ZRX', function () {
            var makerFee = new BigNumber(2);
            var takerFee = new BigNumber(2);
            var signedOrder;
            beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerTokenAddress, zrxTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw on insufficient balance when takerToken is ZRX', function () { return __awaiter(_this, void 0, void 0, function () {
                var balanceToSubtractFromTaker;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            balanceToSubtractFromTaker = new BigNumber(1);
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, takerAddress, coinbase, balanceToSubtractFromTaker)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerBalance)];
                    }
                });
            }); });
            it('should throw on insufficient allowance when takerToken is ZRX', function () { return __awaiter(_this, void 0, void 0, function () {
                var oldAllowance, newAllowanceWhichIsInsufficient;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, zeroEx.token.getProxyAllowanceAsync(zrxTokenAddress, takerAddress)];
                        case 1:
                            oldAllowance = _a.sent();
                            newAllowanceWhichIsInsufficient = oldAllowance.minus(1);
                            return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, takerAddress, newAllowanceWhichIsInsufficient)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerAllowance)];
                    }
                });
            }); });
        });
        describe('should correctly validate fees amounts if maker token is ZRX', function () {
            var signedOrder;
            var txHash;
            it('should not throw if taker will have enough ZRX to pay fees after the transfer', function () { return __awaiter(_this, void 0, void 0, function () {
                var makerFee, takerFee;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            makerFee = new BigNumber(2);
                            takerFee = new BigNumber(2);
                            return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(zrxTokenAddress, takerTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, takerAddress, coinbase, takerFee)];
                        case 2:
                            txHash = _a.sent();
                            return [4 /*yield*/, zeroEx.awaitTransactionMinedAsync(txHash)];
                        case 3:
                            _a.sent();
                            return [4 /*yield*/, orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)];
                        case 4:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should throw if maker will not have enough ZRX to pay fees even after the transfer', function () { return __awaiter(_this, void 0, void 0, function () {
                var makerFee, takerFee;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            makerFee = fillableAmount.plus(1);
                            takerFee = fillableAmount.plus(1);
                            return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(zrxTokenAddress, takerTokenAddress, makerFee, takerFee, makerAddress, takerAddress, fillableAmount, feeRecipient)];
                        case 1:
                            signedOrder = _a.sent();
                            return [4 /*yield*/, zeroEx.token.transferAsync(zrxTokenAddress, takerAddress, coinbase, takerFee)];
                        case 2:
                            txHash = _a.sent();
                            return [4 /*yield*/, zeroEx.awaitTransactionMinedAsync(txHash)];
                        case 3:
                            _a.sent();
                            return [2 /*return*/, expect(orderValidationUtils.validateFillOrderTakerBalancesAllowancesThrowIfInvalidAsync(signedOrder, fillTakerAmount, takerAddress, zrxTokenAddress)).to.be.rejectedWith(src_1.ExchangeContractErrs.InsufficientTakerFeeBalance)];
                    }
                });
            }); });
        });
    });
});
//# sourceMappingURL=order_validation_test.js.map